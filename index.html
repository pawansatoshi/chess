<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Monad Chess Testnet</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/css/chessboard.min.css"/>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
    #board { width: 90%; max-width: 480px; margin: 20px auto; }
    button { margin: 5px; padding: 10px 20px; font-size: 16px; }
    .highlight { background-color: #90ee90 !important; }
    #history, #leaderboard { margin-top: 20px; font-size: 14px; max-width: 480px; margin-left: auto; margin-right: auto; text-align: left; }
    footer { margin-top: 30px; font-size: 14px; }
    footer a { margin: 0 10px; color: #333; text-decoration: none; }
    table { width: 100%; border-collapse: collapse; margin-top: 5px; }
    th, td { border: 1px solid #ccc; padding: 5px; text-align: center; }
    th { background-color: #f0f0f0; }
  </style>
</head>
<body>

  <h1>Monad Chess Testnet</h1>
  <div id="board"></div>

  <div>
    <button id="connectWallet">Connect Wallet</button>
    <button id="createGame" disabled>Create Game (White)</button>
    <button id="joinGame" disabled>Join Game (Black / AI)</button>
    <button id="undoMove" disabled>Undo Last Move</button>
  </div>

  <div id="history"><strong>Move History:</strong><br/></div>
  <div id="leaderboard"><strong>Leaderboard:</strong></div>

  <footer>
    <a href="https://t.me/pawansatoshiji" target="_blank">Telegram</a>
    <a href="https://youtube.com/@PawanSatoshi" target="_blank">YouTube</a>
    <a href="https://x.com/pawansatoshix" target="_blank">X</a>
  </footer>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/1.0.0/chess.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/js/chessboard.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.min.js"></script>

  <script>
    let board = null;
    let game = new Chess();
    let walletAddress = null;
    let playerRole = null;
    let moveHistoryDiv = document.getElementById('history');
    let leaderboardDiv = document.getElementById('leaderboard');

    const connectWalletBtn = document.getElementById('connectWallet');
    const createGameBtn = document.getElementById('createGame');
    const joinGameBtn = document.getElementById('joinGame');
    const undoMoveBtn = document.getElementById('undoMove');

    // Load leaderboard from localStorage
    let leaderboard = JSON.parse(localStorage.getItem('leaderboard')) || {};

    function initBoard() {
      board = Chessboard('board', {
        draggable: true,
        position: 'start',
        onDragStart: (source, piece) => {
          if (game.game_over()) return false;
          if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
              (game.turn() === 'b' && piece.search(/^w/) !== -1)) return false;
        },
        onDrop: (source, target) => {
          const move = game.move({ from: source, to: target });
          if (move === null) return 'snapback';
          updateBoard();
          highlightMoves();
          updateHistory();
          checkGameStatus();
          undoMoveBtn.disabled = false;
          if (!game.game_over() && playerRole === 'white' && game.turn() === 'b') {
            setTimeout(aiMove, 800);
          }
        },
        onMouseoverSquare: highlightMoves,
        onMouseoutSquare: removeHighlights
      });
    }

    function updateBoard() { board.position(game.fen()); }

    function highlightMoves(square) {
      removeHighlights();
      let moves = [];
      if (square) moves = game.moves({ square, verbose: true });
      for (let move of moves) {
        const squareEl = document.querySelector('.square-' + move.to);
        if (squareEl) squareEl.classList.add('highlight');
      }
    }

    function removeHighlights() {
      document.querySelectorAll('.square-55d63').forEach(sq => sq.classList.remove('highlight'));
    }

    async function connectWallet() {
      if (!window.ethereum) return alert('Please install MetaMask');
      const provider = new ethers.BrowserProvider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      const signer = await provider.getSigner();
      walletAddress = await signer.getAddress();
      alert('Wallet connected: ' + walletAddress);
      createGameBtn.disabled = false;
      joinGameBtn.disabled = false;
      if (!leaderboard[walletAddress]) leaderboard[walletAddress] = { wins:0, losses:0, draws:0 };
      renderLeaderboard();
    }

    function createGame() {
      if (!walletAddress) return alert('Connect wallet first!');
      playerRole = 'white';
      alert('Game created as White. Waiting for opponent...');
      joinGameBtn.style.display = 'inline-block';

      setTimeout(() => {
        if (playerRole === 'white' && !game.game_over() && game.turn() === 'b') {
          alert('AI joined as Black!');
          aiMove();
        }
      }, 2000);
    }

    function joinGame() {
      if (!walletAddress) return alert('Connect wallet first!');
      if (playerRole === 'white') return alert('You are already White.');
      playerRole = 'black';
      alert('Joined game as Black!');
      if (game.turn() === 'b') setTimeout(aiMove, 500);
    }

    function aiMove() {
      if (game.game_over()) return;

      const moves = game.moves({ verbose: true });
      let bestMove = null;
      const captures = moves.filter(m => m.captured);
      if (captures.length > 0) bestMove = captures[Math.floor(Math.random() * captures.length)];

      if (!bestMove) {
        const centerSquares = ['e4','d4','e5','d5'];
        const centerMoves = moves.filter(m => centerSquares.includes(m.to));
        if (centerMoves.length > 0) bestMove = centerMoves[Math.floor(Math.random() * centerMoves.length)];
      }

      if (!bestMove) {
        const pieceValue = { p:1, n:3, b:3, r:5, q:9, k:1000 };
        let scoredMoves = moves.map(m => {
          return { move: m, score: m.captured ? pieceValue[m.captured.toLowerCase()] : 0 };
        });
        scoredMoves.sort((a,b) => b.score - a.score);
        bestMove = scoredMoves[0].move;
      }

      game.move(bestMove.san);
      updateBoard();
      highlightMoves();
      updateHistory();
      checkGameStatus();

      if (!game.game_over() && ((playerRole === 'white' && game.turn() === 'b') || (playerRole === 'black' && game.turn() === 'w'))) {
        setTimeout(aiMove, 800);
      }
      undoMoveBtn.disabled = false;
    }

    function updateHistory() {
      moveHistoryDiv.innerHTML = "<strong>Move History:</strong><br/>" + game.history().join(', ');
    }

    function checkGameStatus() {
      if (game.in_checkmate()) {
        alert('Checkmate! Game over.');
        recordResult(playerRole === 'white' ? 'win' : 'loss');
      } else if (game.in_draw()) {
        alert('Draw!');
        recordResult('draw');
      } else if (game.in_check()) alert('Check!');
    }

    function recordResult(result) {
      if (!walletAddress) return;
      if (!leaderboard[walletAddress]) leaderboard[walletAddress] = { wins:0, losses:0, draws:0 };
      if (result === 'win') leaderboard[walletAddress].wins += 1;
      else if (result === 'loss') leaderboard[walletAddress].losses += 1;
      else if (result === 'draw') leaderboard[walletAddress].draws += 1;

      localStorage.setItem('leaderboard', JSON.stringify(leaderboard));
      renderLeaderboard();
    }

    function renderLeaderboard() {
      let html = "<strong>Leaderboard:</strong><table><tr><th>Wallet</th><th>Wins</th><th>Losses</th><th>Draws</th></tr>";
      const sorted = Object.entries(leaderboard).sort((a,b) => b[1].wins - a[1].wins);
      for (let [wallet, stats] of sorted) {
        html += `<tr><td>${wallet}</td><td>${stats.wins}</td><td>${stats.losses}</td><td>${stats.draws}</td></tr>`;
      }
      html += "</table>";
      leaderboardDiv.innerHTML = html;
    }

    undoMoveBtn.addEventListener('click', () => {
      if (game.history().length === 0) return;
      game.undo();
      game.undo();
      updateBoard();
      updateHistory();
      undoMoveBtn.disabled = game.history().length === 0;
    });

    connectWalletBtn.addEventListener('click', async () => { await connectWallet(); initBoard(); });
    createGame
